#![allow(dead_code)] // TODO: Remove later
#[allow(unused_variables)] // TODO: Remove later

// Include the IDL-generated code directly. 
// It defines modules ix_data, accounts_data, typedefs, and the Instruction enum.
include!("../idl.rs"); 

// Use items generated by include!
use ix_data::*; // Args structs (e.g., InitializeArgs)
use accounts_data::*; // Accounts structs (e.g., InitializeAccounts)
use typedefs::*; // Type definitions (e.g., StrategyType)
// Use the generated Instruction enum directly

// Necessary imports for decoding and Protobuf conversion
use anchor_lang::{prelude::Pubkey, AnchorDeserialize, Discriminator}; 
use crate::pb; // Use crate::pb for generated Protobuf types

// Import specific Protobuf types needed
use pb::instruction_args::{self, InstructionArgs}; // The main wrapper enum + its inner module
use pb::meta::Meta;                       // The output struct
// Import specific layout structs needed (add others as necessary)
use pb::pb_initialize_layout::PbInitializeLayout;
use pb::pb_enable_vault_layout::PbEnableVaultLayout;
use pb::pb_set_operator_layout::PbSetOperatorLayout;
use pb::pb_initialize_strategy_layout::{PbInitializeStrategyLayout, PbStrategyBumpsLayout};
use pb::pb_remove_strategy_layout::PbRemoveStrategyLayout;
use pb::pb_remove_strategy2_layout::PbRemoveStrategy2Layout;
use pb::pb_collect_dust_layout::PbCollectDustLayout;
use pb::pb_add_strategy_layout::PbAddStrategyLayout;
use pb::pb_deposit_strategy_layout::PbDepositStrategyLayout;
use pb::pb_withdraw_strategy_layout::PbWithdrawStrategyLayout;
use pb::pb_withdraw2_layout::PbWithdraw2Layout;
use pb::pb_deposit_layout::PbDepositLayout;
use pb::pb_withdraw_layout::PbWithdrawLayout;
use pb::pb_withdraw_directly_from_strategy_layout::PbWithdrawDirectlyFromStrategyLayout;
use pb::pb_claim_rewards_layout::PbClaimRewardsLayout;
use pb::pb_patch_vault_field_in_strategy_layout::PbPatchVaultFieldInStrategyLayout;
use pb::pb_withdraw_mango_layout::PbWithdrawMangoLayout;
use pb::pb_idl_write_layout::PbIdlWriteLayout;
use pb::pb_strategy_type; // Import the enum module

// Other standard imports
use std::collections::HashMap;
use std::str::FromStr;
use anyhow::{Result, anyhow};
use log;
use hex;
use bs58;
use chrono::DateTime;

// Import Solana types needed for process_instruction
use substreams_solana::pb::sf::solana::r#type::v1::CompiledInstruction;

// Meteora Vaults Program ID
const METEORA_VAULTS_PROGRAM_ID: &str = "24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi";

/// Process a single instruction into a Meta object using IDL decoding
pub fn process_instruction(
    instruction: &CompiledInstruction,
    account_keys_str: &[String], // Receive account keys as strings
    block_slot: u64,
    block_time: i64,
    tx_id: &str,
    outer_instruction_index: u32,
    is_inner_instruction: bool,
    actual_inner_index: Option<u32>,
    signer_pubkey_str: Option<&str>,
    outer_program_str: Option<&str>,
) -> Option<Meta> { 
    let program_id = match account_keys_str.get(instruction.program_id_index as usize) {
        Some(id) => id,
        None => {
             log::error!("Program ID index out of bounds");
             return None;
         }
    };

    // Only process instructions for the target program
    if program_id != METEORA_VAULTS_PROGRAM_ID {
        return None;
    }

    let instruction_data = &instruction.data;
    if instruction_data.len() < 8 {
        log::debug!("Instruction data too short for discriminator");
        return None; // Not enough data for discriminator
    }

    // Convert account key strings to Pubkeys for the decoder
    let account_pubkeys: Vec<Pubkey> = account_keys_str.iter()
        .map(|s| Pubkey::from_str(s))
        .filter_map(Result::ok) // Filter out any potential parsing errors
        .collect();
    
    // Ensure we have enough Pubkeys after conversion
    // TODO: Is this check sufficient/correct? What if parsing fails mid-list?
    if account_pubkeys.len() != account_keys_str.len() {
        log::warn!("Failed to convert all account key strings to Pubkeys for tx {}", tx_id);
        // Decide whether to continue or return None. Returning None might be safer.
        // return None;
    }

    // Decode the instruction using the function generated in idl.rs
    match Instruction::decode(&account_pubkeys, instruction_data) {
        Ok(decoded_instruction) => {
            // Successfully decoded, now map to Protobuf Meta
            let mut input_accounts = HashMap::new();
            let args_pb: Option<InstructionArgs>;
            let instruction_type_str: String;

            match decoded_instruction {
                Instruction::Initialize { accounts, args } => {
                    instruction_type_str = "Initialize".to_string();
                    // Manually map account fields using names from generated idl.rs
                    input_accounts.insert("vault".to_string(), accounts.vault.to_string());
                    input_accounts.insert("payer".to_string(), accounts.payer.to_string());
                    input_accounts.insert("tokenVault".to_string(), accounts.tokenVault.to_string());
                    input_accounts.insert("tokenMint".to_string(), accounts.tokenMint.to_string());
                    input_accounts.insert("lpMint".to_string(), accounts.lpMint.to_string());
                    input_accounts.insert("rent".to_string(), accounts.rent.to_string());
                    input_accounts.insert("tokenProgram".to_string(), accounts.tokenProgram.to_string());
                    input_accounts.insert("systemProgram".to_string(), accounts.systemProgram.to_string());
                    
                    // Convert IDL args to PB args
                    args_pb = Some(InstructionArgs {
                        instruction_args: Some(instruction_args::InstructionArgs::Initialize(
                            PbInitializeLayout { 
                                // Assuming InitializeArgs is empty in IDL
                            }
                        ))
                    });
                }
                Instruction::EnableVault { accounts, args } => {
                    instruction_type_str = "EnableVault".to_string();
                    input_accounts.insert("vault".to_string(), accounts.vault.to_string());
                    input_accounts.insert("admin".to_string(), accounts.admin.to_string());
                    
                    args_pb = Some(InstructionArgs {
                        instruction_args: Some(instruction_args::InstructionArgs::EnableVault(
                            PbEnableVaultLayout { 
                                enabled: Some(args.enabled as u32) // Map fields
                            }
                        ))
                    });
                }
                Instruction::SetOperator { accounts, args } => {
                    instruction_type_str = "SetOperator".to_string();
                    input_accounts.insert("vault".to_string(), accounts.vault.to_string());
                    input_accounts.insert("operator".to_string(), accounts.operator.to_string());
                    input_accounts.insert("admin".to_string(), accounts.admin.to_string());
                    
                    args_pb = Some(InstructionArgs {
                        instruction_args: Some(instruction_args::InstructionArgs::SetOperator(
                            PbSetOperatorLayout { }
                        ))
                    });
                }
                Instruction::InitializeStrategy { accounts, args } => {
                     instruction_type_str = "InitializeStrategy".to_string();
                     input_accounts.insert("vault".to_string(), accounts.vault.to_string());
                     input_accounts.insert("strategyProgram".to_string(), accounts.strategyProgram.to_string());
                     input_accounts.insert("strategy".to_string(), accounts.strategy.to_string());
                     input_accounts.insert("reserve".to_string(), accounts.reserve.to_string());
                     input_accounts.insert("collateralVault".to_string(), accounts.collateralVault.to_string());
                     input_accounts.insert("collateralMint".to_string(), accounts.collateralMint.to_string());
                     input_accounts.insert("admin".to_string(), accounts.admin.to_string());
                     input_accounts.insert("systemProgram".to_string(), accounts.systemProgram.to_string());
                     input_accounts.insert("rent".to_string(), accounts.rent.to_string());
                     input_accounts.insert("tokenProgram".to_string(), accounts.tokenProgram.to_string());
                    
                     let pb_bumps = Some(PbStrategyBumpsLayout {
                         strategy_index: Some(args.bumps.strategy_index as u32),
                         other_bumps: args.bumps.other_bumps.iter().map(|&b| b as u32).collect(),
                     });
                     let pb_strategy_type = pb_strategy_type::PbStrategyType::try_from(args.strategy_type as i32).ok();
                    
                     args_pb = Some(InstructionArgs {
                         instruction_args: Some(instruction_args::InstructionArgs::InitializeStrategy(
                             PbInitializeStrategyLayout { 
                                 bumps: pb_bumps,
                                 strategy_type: pb_strategy_type.map(|st| st.into()),
                             }
                         ))
                     });
                 }
                // Add cases for ALL other instruction variants from the IDL...
                // Example: Instruction::Deposit { accounts, args } => { ... }

                // Fallback for unimplemented instructions (should match all variants eventually)
                _ => {
                     log::warn!("Mapping to Protobuf not implemented for decoded instruction variant in tx {}", tx_id);
                     return None; // Or handle as needed
                }
            }

            // Create date string from timestamp
            let dt = DateTime::from_timestamp(block_time, 0).unwrap_or_else(|| DateTime::from_timestamp(0, 0).unwrap());
            let block_date = dt.format("%Y-%m-%d").to_string();

            // Construct the Meta Protobuf
            let meta = Meta {
                tx_id: tx_id.to_string(),
                block_slot,
                block_time,
                block_date,
                instruction_index: Some(outer_instruction_index),
                is_inner_instruction: Some(is_inner_instruction),
                inner_instruction_index: actual_inner_index,
                signer: signer_pubkey_str.map(String::from),
                outer_program: outer_program_str.map(String::from),
                instruction_type: instruction_type_str, // From the match arm
                input_accounts, // Populated from decoded accounts struct
                args: args_pb, // Populated from decoded args struct
            };
            Some(meta)
        }
        Err(e) => {
            log::debug!("Failed to decode instruction using IDL for tx {}: {}", tx_id, e);
            None
        }
    }
}


// --- Helper Functions --- 

// Helper function to parse a fixed-size byte slice into a PubKey string (Can likely be removed if not used elsewhere)
// fn bytes_to_pubkey_str(data: &[u8], offset: usize) -> Result<String, &'static str> {
//     if offset + 32 > data.len() {
//         return Err("Data too short for PubKey");
//     }
//     Ok(bs58::encode(&data[offset..offset + 32]).into_string())
// }
